## ビット全探索とは？

ビット全探索（bit全探索）とは、「要素を選ぶ or 選ばない」のような **すべての部分集合を列挙**したいときに使える探索手法。  
`n` 個の要素について、各要素を **「選ぶか選ばないか」= 2 通り**で考えるため、  
全体の組み合わせは **2^n通り** になる。

ビット演算を使うことで、効率的にすべての組み合わせを列挙できる。

---

## 具体例

たとえば、`n = 3` のとき、以下のような全 8 通りの部分集合を列挙できます：

| ビット列 | 選ばれた要素（0-indexed） |
|----------|-----------------------------|
| `000`    | `[]`                        |
| `001`    | `[0]`                       |
| `010`    | `[1]`                       |
| `011`    | `[0, 1]`                    |
| `100`    | `[2]`                       |
| `101`    | `[0, 2]`                    |
| `110`    | `[1, 2]`                    |
| `111`    | `[0, 1, 2]`                 |

Pythonでは以下のように書けます：

```python
n = 3
for bit in range(1 << n):  # 0〜2^n-1まで
    subset = []
    for i in range(n):
        if bit & (1 << i):  # i番目の要素を選んでいるか
            subset.append(i)
    print(subset)
```

| n   | 2ⁿ通り        | 実行時間の目安（1秒以内に収まるか）                   |
|------|---------------|------------------------------------------------------|
| 15   | 32,768        | 十分余裕                                             |
| 20   | 1,048,576     | 条件次第でギリ実行可能                               |
| 22   | 4,194,304     | 処理が軽ければ可能                                   |
| 24   | 16,777,216    | ギリギリ。高速処理前提                               |
| 25   | 33,554,432    | ほぼ限界。処理内容が超軽量なら可能                   |
| 26以上 | 67,108,864〜 | Pythonでは現実的に厳しい                             |
